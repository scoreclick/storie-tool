[1mdiff --git a/src/components/video-converter.js b/src/components/video-converter.js[m
[1mindex ec85680..28d222d 100644[m
[1m--- a/src/components/video-converter.js[m
[1m+++ b/src/components/video-converter.js[m
[36m@@ -27,6 +27,27 @@[m [mexport default function VideoConverter() {[m
   const animationFrameRef = useRef(null);[m
   const recordedFramesRef = useRef([]);[m
   [m
[32m+[m[32m  // Reset all state and dimensions[m
[32m+[m[32m  const resetState = useCallback(() => {[m
[32m+[m[32m    setIsPlaying(false);[m
[32m+[m[32m    setIsRecording(false);[m
[32m+[m[32m    setCountdown(0);[m
[32m+[m[32m    setExportProgress(0);[m
[32m+[m[32m    recordedFramesRef.current = [];[m
[32m+[m
[32m+[m[32m    // Reset canvas if it exists[m
[32m+[m[32m    if (canvasRef.current) {[m
[32m+[m[32m      const ctx = canvasRef.current.getContext('2d');[m
[32m+[m[32m      ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Cancel any ongoing animation frame[m
[32m+[m[32m    if (animationFrameRef.current) {[m
[32m+[m[32m      cancelAnimationFrame(animationFrameRef.current);[m
[32m+[m[32m      animationFrameRef.current = null;[m
[32m+[m[32m    }[m
[32m+[m[32m  }, []);[m
[32m+[m
   // Clean up URLs when component unmounts[m
   useEffect(() => {[m
     return () => {[m
[36m@@ -37,23 +58,42 @@[m [mexport default function VideoConverter() {[m
 [m
   // Handle video file upload[m
   const handleVideoUpload = (file) => {[m
[32m+[m[32m    // Clean up existing URLs[m
     if (videoUrl) URL.revokeObjectURL(videoUrl);[m
     if (outputVideoUrl) {[m
       URL.revokeObjectURL(outputVideoUrl);[m
       setOutputVideoUrl('');[m
     }[m
     [m
[32m+[m[32m    // Reset state before loading new video[m
[32m+[m[32m    resetState();[m
[32m+[m[41m    [m
[32m+[m[32m    // Set new video[m
     setVideoFile(file);[m
     setVideoUrl(URL.createObjectURL(file));[m
[31m-    setIsPlaying(false);[m
[31m-    setIsRecording(false);[m
[31m-    setExportProgress(0);[m
[31m-    recordedFramesRef.current = [];[m
   };[m
   [m
   // Load video metadata when video is loaded[m
   const handleVideoLoad = (metadata) => {[m
     setVideoMetadata(metadata);[m
[32m+[m[41m    [m
[32m+[m[32m    // Reset mask position and size when new video is loaded[m
[32m+[m[32m    if (maskRef.current && videoRef.current) {[m
[32m+[m[32m      const video = videoRef.current;[m
[32m+[m[32m      const videoRect = video.getBoundingClientRect();[m
[32m+[m[41m      [m
[32m+[m[32m      // Calculate initial mask size (e.g., 9:16 aspect ratio)[m
[32m+[m[32m      const maskWidth = videoRect.width * 0.8; // 80% of video width[m
[32m+[m[32m      const maskHeight = (maskWidth * 16) / 9; // maintain 9:16 aspect ratio[m
[32m+[m[41m      [m
[32m+[m[32m      // Update mask style[m
[32m+[m[32m      Object.assign(maskRef.current.style, {[m
[32m+[m[32m        width: `${maskWidth}px`,[m
[32m+[m[32m        height: `${maskHeight}px`,[m
[32m+[m[32m        left: `${(videoRect.width - maskWidth) / 2}px`,[m
[32m+[m[32m        top: `${(videoRect.height - maskHeight) / 2}px`[m
[32m+[m[32m      });[m
[32m+[m[32m    }[m
   };[m
   [m
   // Start recording process with countdown[m
[36m@@ -92,9 +132,8 @@[m [mexport default function VideoConverter() {[m
   [m
   // Restart recording process[m
   const handleRestartRecording = () => {[m
[31m-    // Stop current recording[m
[31m-    setIsRecording(false);[m
[31m-    setIsPlaying(false);[m
[32m+[m[32m    // Reset all state and dimensions[m
[32m+[m[32m    resetState();[m
     [m
     // Reset video to beginning[m
     if (videoRef.current) {[m
[36m@@ -102,9 +141,6 @@[m [mexport default function VideoConverter() {[m
       videoRef.current.pause();[m
     }[m
     [m
[31m-    // Clear recorded frames[m
[31m-    recordedFramesRef.current = [];[m
[31m-    [m
     // Small delay before starting new countdown[m
     setTimeout(() => {[m
       startRecording();[m
